# MySQL数据库

#### 锁

在Innodb中，同时支持表锁和行锁，表锁和行锁均有两种：**共享锁**和**排他锁**，以行锁为例：

**共享锁（shared lock）**：

​	共享锁允许获取到锁的事务对行数据进行读取。

**排他锁（exclusive lock）**：

​	排他锁允许获取到锁的事务对行数据进行删除和更新。

共享锁和排他锁的互斥关系如表所示：

|      | S    | X    |
| ---- | ---- | ---- |
| S    | 共存 | 互斥 |
| X    | 互斥 | 互斥 |

**意向锁：**意向锁是一种加在表上面的锁，表明事务接下来想要获取的行锁是哪一种（排他锁还是共享锁）。意向锁有两种：意向共享锁、意向排他锁。

​	**意向共享锁（IS）**：表明事务准备获取个别行的共享锁。

​	**意向排他锁（IX）**：表明事务准备获取个别行的排他锁。

意向锁存在的目的是为了解决表锁和行锁之间存在的冲突。考虑这种情况：事务A锁住了表中的一行，让这一行只能读，不能写，之后事务B申请整个表的写锁，如果B申请成功，那么理论上它可以需修改任意一行，显然这和A的行锁是矛盾的，因此数据库需要判断该冲突，

第一步：判断表是否被其他事务用表锁锁住

第二步：判断表中每一行是否被行锁锁住

第一步很好判断，第二步效率很低，因此需要意向锁，事务在获取行锁之前需要获取表上的意向锁，上述的判断过程变成了如下所示：

第一步：不变

第二步：发现表上有意向锁，说明表中有些行被共享行锁锁住了，因此事务B申请表的写锁会被阻塞。

表锁的兼容性如下表所示：

|      | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | 冲突 | 冲突 | 冲突 | 冲突 |
| IX   | 冲突 | 兼容 | 冲突 | 兼容 |
| S    | 冲突 | 冲突 | 兼容 | 兼容 |
| IS   | 冲突 | 兼容 | 兼容 | 兼容 |



#### 事务

原子性（Atomicity）：一个事务必须被视为一个不可分割的最小工作但愿，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分。

一致性（Consistency）：数据库总是从一个一致性的状态转到另一个一致性的状态。

隔离性（Isolation）：一个事务所作的修改在最终提交之前，对其他事务是不可见的。

持久性（durability）：一旦事务提交，则其所作的修改就会永久保存在数据库中。



#### 隔离级别

**READ UNCOMMITTED（读未提交）**

​	在READ UNCOMMITTED级别下，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，也被称为脏读（Dirty Read）。从性能上来说，READ UNCOMMITTED不会比其他隔离级别好太多，但是会造成更多的问题，因此一般很少使用。

**READ COMMITTED（读已提交）**

​	事务从开始到提交之前，所作的任何修改对其他事务都是不可见的。存在的问题为不可重复读（nonrepeatable read）,一个事务中两次执行同样的查询，可能会得到不一样的结果。

**REPETABLE READ（可重复读）（MySQL默认隔离级别）**

​	在同一个事务中，多次读取同样的记录结果是一样的。存在幻读问题，即当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新纪录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过MVCC（多版本并发控制）解决了幻读问题。

**SERIALIZABLE（可串行化）**

​	最高隔离级别，强制数据串行执行，避免了幻读的问题。

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | NO     |
| READ COMMITTED   | No         | Yes              | Yes        | NO     |
| REPETABLE READ   | NO         | NO               | Yes        | NO     |
| SERIALIZABLE     | No         | No               | No         | Yes    |

#### 死锁：

两个或多个事务在同一资源上相互占用，并请求锁定对方资源，而导致恶性循环的现象。

解决方法：Innodb通过回滚持有最少行级排他锁的事务，便可以打破死锁。

#### 多版本并发控制（MVCC）

start_version <= transaction_version <= delete_version

