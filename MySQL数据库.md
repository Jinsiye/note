# MySQL数据库

#### 锁

共享锁

排他锁

读锁

写锁



#### 事务

原子性（Atomicity）：一个事务必须被视为一个不可分割的最小工作但愿，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分。

一致性（Consistency）：数据库总是从一个一致性的状态转到另一个一致性的状态。

隔离性（Isolation）：一个事务所作的修改在最终提交之前，对其他事务是不可见的。

持久性（durability）：一旦事务提交，则其所作的修改就会永久保存在数据库中。



#### 隔离级别

**READ UNCOMMITTED（读未提交）**

​	在READ UNCOMMITTED级别下，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，也被称为脏读（Dirty Read）。从性能上来说，READ UNCOMMITTED不会比其他隔离级别好太多，但是会造成更多的问题，因此一般很少使用。

**READ COMMITTED（读已提交）**

​	事务从开始到提交之前，所作的任何修改对其他事务都是不可见的。存在的问题为不可重复读（nonrepeatable read）,一个事务中两次执行同样的查询，可能会得到不一样的结果。

**REPETABLE READ（可重复读）（MySQL默认隔离级别）**

​	在同一个事务中，多次读取同样的记录结果是一样的。存在幻读问题，即当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新纪录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过MVCC（多版本并发控制）解决了幻读问题。

**SERIALIZABLE（可串行化）**

​	最高隔离级别，强制数据串行执行，避免了幻读的问题。

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | NO     |
| READ COMMITTED   | No         | Yes              | Yes        | NO     |
| REPETABLE READ   | NO         | NO               | Yes        | NO     |
| SERIALIZABLE     | No         | No               | No         | Yes    |

#### 死锁：

两个或多个事务在同一资源上相互占用，并请求锁定对方资源，而导致恶性循环的现象。

解决方法：Innodb通过回滚持有最少行级排他锁的事务，便可以打破死锁。

#### 多版本并发控制（MVCC）

start_version <= transaction_version <= delete_version

