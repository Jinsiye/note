# 设计模式

#### 策略模式

**定义：**

​	策略模式定义了算法族，分别分装起来，让它们之间可以互相替换。

**类图：**

![策略模式类图](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\策略模式.png)



#### 观察者模式

**定义：**观察者模式定义了对象之间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知

**类图：**

![观察者模式类图](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\观察者模式.png)



#### 装饰者模式

**定义：**在不改变原有类文件和使用继承的情况下，动态地拓展一个对象的功能，它通过创建一个包装对象，也就是装饰对象来包裹真实的对象。

**类图：**

![装饰者模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\装饰者模式.png)



#### 工厂方法

**定义：**又称为工厂模式，工厂父类定义创建产品对象的接口，工厂子类负责生成具体产品对象，这样做的目的将产品类的实例化操作延迟到工厂子类中，通过工厂子类来确定究竟应该实例化哪一个具体产品。工厂方法是对简单工厂的进一步抽象和推广。

**类图：**

![工厂方法](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\工厂方法.png)

**优点：**

1. 用户无需了解具体产品创建细节，用户只需要关心产品对应的工厂，甚至不需要了解产品的类名。
2. 系统加入新产品的时候，无需修改已有代码，只需要加入具体产品类和具体工厂类，符合开闭原则。

**缺点：**

1. 添加新产品和新工厂需要新建类，系统中类的个数会增加，增加了系统复杂度和可理解性。
2. 抽象层的引入，增加了系统的抽象性和理解难度。



#### 抽象工厂

**定义：**抽象工厂模式提供了一个接口，用于创建相关或者依赖对象的家族，而不需要明确制定具体类。 抽象工厂是工厂模式中最抽象和最具有不普遍性的模式，与工厂方法相比，抽象工厂等级结构可以创建分属在不同等级结构的一个产品族中的所有对象。

> **产品等级结构**：产品等级结构即产品的继承结构，如一个抽象类电视，其子类有海尔、海信、TCL，则抽象电视机与具体电视机之间就构成了一个产品等级结构。
>
> **产品族**：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视、海尔电冰箱。海尔电视位于电视产品等级结构中，海尔电冰箱位于冰箱产品等级结构中。

**类图：**

![抽象工厂](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\抽象工厂.png)

**优点：**

1. 隔离了具体产品对象的创建，用户并不需要知道什么被创建，替换具体工厂的时候更为容易。
2. 新增具体工厂和产品族很方便，无需修改已有代码，符合开闭原则。

**缺点：**

1. 类多，复杂性高，理解性差
2. 如果要新增产品等级结构，需要修改抽象工厂和具体工厂，不符合开闭原则（开闭原则的倾斜性）



#### 命令模式

**定义：**将“请求“封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式支持可撤销的操作。

**类图：**

![命令模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\命令模式.png)



**优点：**

1. 降低系统的耦合度
2. 新的命令能够很容易地加入到系统中
3. 可以比较容易地设计一个命令队列和宏命令
4. 可以方便地实现对请求的Undo和Redo

**缺点：**

1. 类的数量会变的很多，每一个命令都需要一个类来实现



#### 适配器模式

**定义：**将一个类的结构，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

**类图：**

对象适配器：

![对象适配器](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\对象适配器模式.png)

类适配器：

![类适配器](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\类适配器.png)

**优点：**

1. 已有的被适配类可以被复用，且对用户来说是透明的。
2. 目标接口与被适配类之间解耦。
3. 拓展性很好，可以在不修改原有代码的基础上新增适配器。

> 对象适配器：
>
> 1. 一个对象适配器可以适配不同的Adaptee，即可以适配Adaptee和他的子类
>
> 类适配器：
>
> 1. 由于继承自被适配者，适配器可以重写父类的方法，使得适配器更加灵活

**缺点：**

> 对象适配器
>
> 1. 置换被适配者方法很麻烦，需要创建被适配者子类，在子类中重写父类方法，再使用对象适配器进行适配。
>
> 类适配器：
>
> 1. 不能够将适配器适用到被适配者子类上
> 2. 不支持多重继承的语言来说，无法使用类适配器