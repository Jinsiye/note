# 设计模式

#### 策略模式

**定义：**

​	策略模式定义了算法族，分别分装起来，让它们之间可以互相替换。

**类图：**

![策略模式类图](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\策略模式.png)



#### 观察者模式

**定义：**观察者模式定义了对象之间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知

**类图：**

![观察者模式类图](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\观察者模式.png)



#### 装饰者模式

**定义：**在不改变原有类文件和使用继承的情况下，动态地拓展一个对象的功能，它通过创建一个包装对象，也就是装饰对象来包裹真实的对象。

**类图：**

![装饰者模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\装饰者模式.png)



#### 工厂方法

**定义：**又称为工厂模式，工厂父类定义创建产品对象的接口，工厂子类负责生成具体产品对象，这样做的目的将产品类的实例化操作延迟到工厂子类中，通过工厂子类来确定究竟应该实例化哪一个具体产品。工厂方法是对简单工厂的进一步抽象和推广。

**类图：**

![工厂方法](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\工厂方法.png)

**优点：**

1. 用户无需了解具体产品创建细节，用户只需要关心产品对应的工厂，甚至不需要了解产品的类名。
2. 系统加入新产品的时候，无需修改已有代码，只需要加入具体产品类和具体工厂类，符合开闭原则。

**缺点：**

1. 添加新产品和新工厂需要新建类，系统中类的个数会增加，增加了系统复杂度和可理解性。
2. 抽象层的引入，增加了系统的抽象性和理解难度。



#### 抽象工厂

**定义：**抽象工厂模式提供了一个接口，用于创建相关或者依赖对象的家族，而不需要明确制定具体类。 抽象工厂是工厂模式中最抽象和最具有不普遍性的模式，与工厂方法相比，抽象工厂等级结构可以创建分属在不同等级结构的一个产品族中的所有对象。

> **产品等级结构**：产品等级结构即产品的继承结构，如一个抽象类电视，其子类有海尔、海信、TCL，则抽象电视机与具体电视机之间就构成了一个产品等级结构。
>
> **产品族**：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视、海尔电冰箱。海尔电视位于电视产品等级结构中，海尔电冰箱位于冰箱产品等级结构中。

**类图：**

![抽象工厂](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\抽象工厂.png)

**优点：**

1. 隔离了具体产品对象的创建，用户并不需要知道什么被创建，替换具体工厂的时候更为容易。
2. 新增具体工厂和产品族很方便，无需修改已有代码，符合开闭原则。

**缺点：**

1. 类多，复杂性高，理解性差
2. 如果要新增产品等级结构，需要修改抽象工厂和具体工厂，不符合开闭原则（开闭原则的倾斜性）



#### 命令模式

**定义：**将“请求“封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式支持可撤销的操作。

**类图：**

![命令模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\命令模式.png)



**优点：**

1. 降低系统的耦合度
2. 新的命令能够很容易地加入到系统中
3. 可以比较容易地设计一个命令队列和宏命令
4. 可以方便地实现对请求的Undo和Redo

**缺点：**

1. 类的数量会变的很多，每一个命令都需要一个类来实现



#### 适配器模式

**定义：**将一个类的结构，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

**类图：**

对象适配器：

![对象适配器](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\对象适配器模式.png)

类适配器：

![类适配器](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\类适配器.png)

**优点：**

1. 已有的被适配类可以被复用，且对用户来说是透明的。
2. 目标接口与被适配类之间解耦。
3. 拓展性很好，可以在不修改原有代码的基础上新增适配器。

> 对象适配器：
>
> 1. 一个对象适配器可以适配不同的Adaptee，即可以适配Adaptee和他的子类
>
> 类适配器：
>
> 1. 由于继承自被适配者，适配器可以重写父类的方法，使得适配器更加灵活

**缺点：**

> 对象适配器
>
> 1. 置换被适配者方法很麻烦，需要创建被适配者子类，在子类中重写父类方法，再使用对象适配器进行适配。
>
> 类适配器：
>
> 1. 不能够将适配器适用到被适配者子类上
> 2. 不支持多重继承的语言来说，无法使用类适配器



#### 外观模式

**定义：**提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更**容易使用**。

**类图：**

![外观模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\外观模式.png)

**优点：**

1. 对客户端屏蔽子系统组件，客户端代码变得简单，与之关联的对象减少
2. 子系统与客户端之间维持着松耦合的关系，子系统组件变化不会应用到调用它的客户端类

**缺点：**

1. 不能够很好限制客户使用子系统类
2. 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或者客户端代码，违背了开闭原则。



#### 模板方法

**定义：**在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

**类图：**

![模板方法](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\模板方法.png)

**优点：**

1. 重用代码，模板方法通过把不变的行为搬到父类，去除了子类中重复的代码
2. 子类实现算法的细节，有助于算法的拓展，父类调用子类的实现，通过子类拓展新的行为，符合开闭原则。

**缺点：**

1. 增加了理解难度



#### 状态模式

**定义：**允许对象在内部装填改变时改变它的行为，对象看起来好像修改了它的类。

**类图：**

![状态模式](C:\Users\siye.jsy\Desktop\学习资料\笔记\pictures\design_pattern\状态模式.png)

**优点：**

1. 封装了转换规则，符合迪米特法则。
2. 将所有与某个状态有关的行为放在一个类中，并且方便地增加心的状态，只需要改变对象状态即改变对象行为。
3. 可以让多个环境共享一个状态对象，从而减少系统中对象的个数。

**缺点：**

1. 增加系统类和对象的个数。
2. 状态模式的结构较为复杂，特别是状态转换的语句，较为难以理解。
3. 对开闭原则支持的不太好，增加新状态就需要修改原有状态中的状态转换语句；状态需要新增方法的时候，会造成大量的改动。

